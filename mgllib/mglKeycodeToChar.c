#ifdef documentation
=========================================================================

     program: mglKeycodeToChar.c
          by: Jonas Larsson
        date: 09/12/06
     purpose: return the (first) char corresponding to a keycode.  
   copyright: (c) 2006 Justin Gardner, Jonas Larsson (GPL see mgl/COPYING)

=========================================================================
#endif

/////////////////////////
//   include section   //
/////////////////////////
#include "mgl.h"
#ifdef __linux__
#include <sys/time.h>
#endif

/////////////
//   main   //
//////////////
void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
{

  int verbose = mglGetGlobalDouble("verbose");

  int nkeys,i;
  if (nrhs == 1 && (mxGetPr(prhs[0]) != NULL)) {
    nkeys=mxGetNumberOfElements(prhs[0]);
  } else {
    usageError("mglKeycodeToChar");
  }

  mxArray * out=mxCreateCellMatrix(1,nkeys);

#ifdef __APPLE__

  /*
Converts a virtual key code to a character code based on a 'KCHR' resource.

UInt32 KeyTranslate (
   const void * transData,
   UInt16 keycode,
   UInt32 * state
);

Parameters

transData

    A pointer to the 'KCHR' resource that you want the KeyTranslate function to use when converting the key code to a character code. 
keycode

    A 16-bit value that your application should set so that bits 0?6 contain the virtual key code and bit 7 contains either 1 to indicate an up stroke or 0 to indicate a down stroke of the key. Bits 8?15 have the same interpretation as the high byte of the modifiers field of the event structure and should be set according to the needs of your application. 
state

    A pointer to a value that your application should set to 0 the first time it calls KeyTranslate or any time your application calls KeyTranslate with a different 'KCHR' resource. Thereafter, your application should pass the same value in the state parameter as KeyTranslate returned in the previous call. 

Return Value
Discussion

The KeyTranslate function returns a 32-bit value that gives the character code for the virtual key code specified by the keycode parameter.

The KeyTranslate function returns the values that correspond to one or possibly two characters that are generated by the specified virtual key code. For example, a given virtual key code might correspond to an alphabetic character with a separate accent character. For example, when the user presses Option-E followed by N, you can map this through the KeyTranslate function using the U.S. 'KCHR' resource to produce ?n, which KeyTranslate returns as two characters in the bytes labeled Character code 1 and Character code 2. If KeyTranslate returns only one character code, it is always in the byte labeled Character code 2. However, your application should always check both bytes labeled Character code 1 and Character code 2 for possible values that map to the virtual key code.

   */

  void *kchr;
  UInt32 state=0;
  KeyboardLayoutRef layout;
  if (KLGetCurrentKeyboardLayout(&layout) != noErr) {
    mexPrintf("Error retrieving current layout\n");
    mxFree(out);
    return;
  }

  //  if (KLGetKeyboardLayoutProperty(layout, kKLKCHRData, const_cast<const void**>(&kchr)) != noErr) {
  if (KLGetKeyboardLayoutProperty(layout, kKLKCHRData, (const void **) (&kchr)) != noErr) {
    mexPrintf("Couldn't load active keyboard layout\n");
    mxFree(out);
    return;
  }

  int bullshitFromSystem=1;
  const void * bullshitFromSystemptr=(void *)&bullshitFromSystem;
  if (KLGetKeyboardLayoutProperty(layout, kKLKind, (&bullshitFromSystemptr)) != noErr) {
    mexPrintf("Couldn't load active keyboard layout\n");
    mxFree(out);
    return;
  }

  char c[2];
  c[1]=0;
  for (i=0; i<nkeys; i++) {
    // convert double to keycode. We ignore all modifiers.
    UInt16 keycode=(UInt16)*(mxGetPr(prhs[0])+i) - 1; // remove 1-offset  

    UInt32 charcode=KeyTranslate( kchr, keycode, &state );

    // get byte corresponding to character
    c[0] = (char) (charcode);
    
    mxSetCell(out, i, mxCreateString( c ));

  }

#endif

#ifdef __linux__
  
  // Compare the beautiful simplicity of the following code with the Mac horrors above. 
  // Amazing considering that X was developed *before* Apple's API. 

  Display * dpy;
  int dpyptr=(int)mglGetGlobalDouble("XDisplayPointer");
  if (dpyptr<=0) {
    // open a dummy display
    dpy=XOpenDisplay(0);
  } else {
    dpy=(Display *)dpyptr;
  }
  
  for (i=0; i<nkeys; i++) {
    KeySym keysym=XKeycodeToKeysym(dpy, (int)*(mxGetPr(prhs[0])+i)-1, 0);// remove 1-offset  
    if (keysym!=NoSymbol) 
      mxSetCell(out, i, mxCreateString( XKeysymToString(keysym)));
  }

  if (dpyptr<=0) {
    XCloseDisplay(dpy);
  }
  
#endif 

  plhs[0]=out;

  
}

